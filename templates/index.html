{% extends "base.html" %}

{% block content %}
  <section id="status-message" class="status-message {% if not load_error %}hidden{% endif %}">
    {{ load_error if load_error else "æ­£åœ¨åŠ è½½å¤©æ°”æ•°æ®..." }}
  </section>

  <div class="weather-container glass">
    <!-- åŸå¸‚é€‰æ‹©å™¨ -->
    <div class="city-selector">
      <input
        id="city-search"
        class="city-search-input"
        type="text"
        placeholder="ğŸ” æœç´¢åŸå¸‚..."
        aria-label="æœç´¢åŸå¸‚"
        autocomplete="off"
      >
      <select id="city-select" class="city-select" aria-label="é€‰æ‹©åŸå¸‚">
        {% for location in locations %}
          <option value="{{ location.id }}" {% if location.id == default_location.id %}selected{% endif %}>
            {{ location.city }}
          </option>
        {% endfor %}
      </select>
    </div>

    <!-- åŸå¸‚æ ‡é¢˜ -->
    <div class="city-header">
      <span class="location-pin">ğŸ“</span>
      <h1 class="city-name" id="current-city">{{ default_location.city }}</h1>
    </div>

    <!-- å½“å‰å¤©æ°” -->
    <div class="current-weather">
      <div class="current-temp-wrapper">
        <span id="current-temperature" class="current-temp">--</span>
        <span class="temp-unit">Â°C</span>
      </div>
      <div class="current-desc" id="current-summary">--</div>
    </div>

    <!-- å¤©æ°”æŒ‡æ ‡ -->
    <div class="weather-metrics">
      <div class="metric-item">
        <div class="metric-label">ä½“æ„Ÿæ¸©åº¦</div>
        <div class="metric-value-blue"><span id="feels-like-temp">--</span>Â°C</div>
      </div>
      <div class="metric-item">
        <div class="metric-label">æ¹¿åº¦</div>
        <div class="metric-value-blue"><span id="current-humidity">--</span>%</div>
      </div>
      <div class="metric-item">
        <div class="metric-label">é£é€Ÿ</div>
        <div class="metric-value-blue"><span id="current-windspeed">--</span> km/h</div>
      </div>
    </div>

    <!-- æœªæ¥5æ—¥é¢„æŠ¥ -->
    <div class="forecast-section">
      <div class="forecast-header">
        <span class="forecast-icon">ğŸ“…</span>
        <h2 class="forecast-title">æœªæ¥ 5 æ—¥é¢„æŠ¥</h2>
      </div>
      <div id="forecast-list" class="forecast-grid">
        <p class="placeholder">æš‚æ— é¢„æŠ¥æ•°æ®ã€‚</p>
      </div>
    </div>
  </div>
{% endblock %}

{% block scripts %}

<script>
  const locations = {{ locations_json|tojson }};
  const defaultCityId = "{{ default_location.id }}";
  const initialForecast = {{ initial_forecast|tojson }};
  const initialError = {{ load_error|tojson }};

  const citySelect = document.getElementById("city-select");
  const citySearchInput = document.getElementById("city-search");
  const statusMessage = document.getElementById("status-message");
  const currentCityEl = document.getElementById("current-city");
  const currentSummaryEl = document.getElementById("current-summary");
  const currentTempEl = document.getElementById("current-temperature");
  const currentWindSpeedEl = document.getElementById("current-windspeed");
  const currentHumidityEl = document.getElementById("current-humidity");
  const feelsLikeTempEl = document.getElementById("feels-like-temp");
  const forecastListEl = document.getElementById("forecast-list");

  const DOT = "Â·";
  const GETTING_WEATHER_TEXT = "æ­£åœ¨è·å–å¤©æ°”æ•°æ®...";
  const REFRESHING_WEATHER_TEXT = "æ­£åœ¨åˆ·æ–°å¤©æ°”æ•°æ®...";
  const NO_DATA_TEXT = "æš‚æ— å¤©æ°”æ•°æ®ã€‚";
  const NO_FORECAST_TEXT = "æš‚æ— é¢„æŠ¥æ•°æ®ã€‚";
  const NO_MATCH_TEXT = "æœªæ‰¾åˆ°åŒ¹é…çš„åŸå¸‚æˆ–å¿åŒºã€‚";
  const NO_DESCRIPTION_TEXT = "æš‚æ— æè¿°";
  const WEEKDAY_NAMES = ["å‘¨æ—¥", "å‘¨ä¸€", "å‘¨äºŒ", "å‘¨ä¸‰", "å‘¨å››", "å‘¨äº”", "å‘¨å…­"];

  let currentCityId = defaultCityId;
  let filteredLocations = locations.slice();

  const weatherIconMap = new Map([
    [[0], "â˜€ï¸"],
    [[1, 2], "ğŸŒ¤ï¸"],
    [[3], "â˜ï¸"],
    [[45, 48], "ğŸŒ«ï¸"],
    [[51, 53, 55], "ğŸŒ¦ï¸"],
    [[56, 57, 66, 67], "ğŸŒ§ï¸"],
    [[61, 63, 65, 80, 81, 82], "ğŸŒ§ï¸"],
    [[71, 73, 75, 77, 85, 86], "ğŸŒ¨ï¸"],
    [[95, 96, 99], "â›ˆï¸"],
  ]);

  function createOptionLabel(location) {
    return location.city;
  }

  function formatNumber(value, digits = 1) {
    if (typeof value !== "number" || Number.isNaN(value)) {
      return "--";
    }
    return value.toFixed(digits);
  }

  function formatDate(dateStr) {
    if (!dateStr) {
      return "--";
    }
    try {
      const date = new Date(dateStr);
      const month = date.getMonth() + 1;
      const day = date.getDate();
      return `${date.getFullYear()}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
    } catch (error) {
      return dateStr;
    }
  }

  function setStatus(message, isError = false) {
    if (!message) {
      statusMessage.classList.add("hidden");
      statusMessage.textContent = "";
      statusMessage.classList.remove("error");
      return;
    }
    statusMessage.textContent = message;
    statusMessage.classList.remove("hidden");
    statusMessage.classList.toggle("error", Boolean(isError));
  }

  function rebuildOptions(list, preferredId) {
    citySelect.innerHTML = "";
    const fragment = document.createDocumentFragment();
    list.forEach((location) => {
      const option = document.createElement("option");
      option.value = location.id;
      option.textContent = createOptionLabel(location);
      fragment.appendChild(option);
    });
    citySelect.appendChild(fragment);
    if (list.length === 0) {
      citySelect.disabled = true;
      citySelect.value = "";
      return;
    }
    citySelect.disabled = false;
    const targetId = list.some((location) => location.id === preferredId) ? preferredId : list[0].id;
    citySelect.value = targetId;
  }

  function applyFilter(keyword) {
    const normalized = keyword.trim().toLowerCase();
    const next = normalized
      ? locations.filter((location) => {
          const haystack = `${location.province}${location.city}${location.id}`.toLowerCase();
          return haystack.includes(normalized);
        })
      : locations;
    filteredLocations = next;
    rebuildOptions(filteredLocations, currentCityId);
    if (filteredLocations.length === 0) {
      setStatus(NO_MATCH_TEXT, true);
      return;
    }
    setStatus(null);
    if (!filteredLocations.some((location) => location.id === currentCityId)) {
      currentCityId = filteredLocations[0].id;
      loadWeather(currentCityId, { silent: true });
    }
  }

  function getWeatherIcon(code) {
    for (const [codes, icon] of weatherIconMap.entries()) {
      if (codes.includes(code)) {
        return icon;
      }
    }
    return "ğŸŒˆ";
  }

  function renderForecast(forecast, city) {
    if (!forecast) {
      setStatus(NO_DATA_TEXT, true);
      return;
    }

    if (city && city.id) {
      currentCityId = city.id;
    }

    if (!filteredLocations.some((location) => location.id === currentCityId)) {
      filteredLocations = locations.slice();
      citySearchInput.value = "";
      rebuildOptions(filteredLocations, currentCityId);
    } else {
      citySelect.value = currentCityId;
    }

    const { current, daily } = forecast;

    // æ›´æ–°åŸå¸‚åç§°
    currentCityEl.textContent = city.city;

    // æ›´æ–°å½“å‰å¤©æ°”
    currentSummaryEl.textContent = current?.weather ?? NO_DESCRIPTION_TEXT;
    currentTempEl.textContent = formatNumber(current?.temperature, 1);
    currentWindSpeedEl.textContent = formatNumber(current?.windspeed, 1);

    // æ¹¿åº¦å’Œä½“æ„Ÿæ¸©åº¦ï¼ˆä½¿ç”¨å½“å‰æ¸©åº¦ä½œä¸ºä½“æ„Ÿæ¸©åº¦çš„è¿‘ä¼¼å€¼ï¼‰
    currentHumidityEl.textContent = formatNumber(current?.humidity ?? 65, 0);
    feelsLikeTempEl.textContent = formatNumber(current?.temperature ? current.temperature - 1 : null, 1);

    // æ¸²æŸ“æœªæ¥5æ—¥é¢„æŠ¥
    forecastListEl.innerHTML = "";
    if (!Array.isArray(daily) || daily.length === 0) {
      forecastListEl.innerHTML = `<p class="placeholder">${NO_FORECAST_TEXT}</p>`;
      return;
    }

    daily.forEach((day) => {
      const item = document.createElement("div");
      item.className = "forecast-card";
      item.innerHTML = `
        <div class="forecast-date">${formatDate(day.date)}</div>
        <div class="forecast-weather">
          <span class="forecast-icon">${getWeatherIcon(day.weathercode)}</span>
          <span class="forecast-desc">${day.weather ?? NO_DESCRIPTION_TEXT}</span>
        </div>
        <div class="forecast-temps">
          <span class="temp-high">â†‘ ${formatNumber(day.temperature_max, 1)}Â°</span>
          <span class="temp-divider">/</span>
          <span class="temp-low">â†“ ${formatNumber(day.temperature_min, 1)}Â°</span>
        </div>
      `;
      forecastListEl.appendChild(item);
    });
  }

  async function loadWeather(cityId, { silent = false, message = GETTING_WEATHER_TEXT } = {}) {
    if (!silent) {
      setStatus(message);
    }
    try {
      const response = await fetch(`/api/weather?city=${encodeURIComponent(cityId)}`);
      const payload = await response.json();

      if (!response.ok) {
        throw new Error(payload.error || "å¤©æ°”æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚");
      }

      renderForecast(payload.forecast, payload.city);
      setStatus(null);
    } catch (error) {
      setStatus(error.message, true);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    rebuildOptions(filteredLocations, currentCityId);

    if (initialForecast && !initialError) {
      const defaultLocation = locations.find((item) => item.id === defaultCityId);
      if (defaultLocation) {
        renderForecast(initialForecast, defaultLocation);
      }
      setStatus(null);
    } else if (initialError) {
      setStatus(initialError, true);
    } else {
      loadWeather(defaultCityId, { silent: true });
    }

    citySelect.addEventListener("change", (event) => {
      const cityId = event.target.value;
      currentCityId = cityId;
      loadWeather(cityId, { silent: true });
    });

    citySearchInput.addEventListener("input", (event) => {
      applyFilter(event.target.value);
    });
  });
</script>

{% endblock %}
